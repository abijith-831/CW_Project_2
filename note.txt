import { useEffect, useState } from "react";

interface RecordType {
  state_name: string;
  s_no: string;
  // add all fields you need...
}

const ApiData = () => {
  const [data, setData] = useState<RecordType[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    async function loadData() {
      try {
        const response = await fetch(
          "https://api.data.gov.in/resource/4dbe5667-7b6b-41d7-82af-211562424d9a?api-key=579b464db66ec23bdd000001cdd3946e44ce4aad7209ff7b23ac571b&format=json"
        );

        const json = await response.json();
        console.log("API response:", json);

        setData(json.records); // API returns { records: [...] }
        setLoading(false);
      } catch (error) {
        console.error("Error fetching API:", error);
        setLoading(false);
      }
    }

    loadData();
  }, []);

  if (loading) return <p>Loading...</p>;

  return (
    <div className="p-4">
      <h2 className="text-xl font-bold mb-3">API Data</h2>

      <ul className="space-y-2">
        {data.map((item, index) => (
          <li key={index} className="p-2 bg-gray-200 rounded">
            {item.state_name} â€” {item.s_no}
          </li>
        ))}
      </ul>
    </div>
  );
};

export default ApiData;
Got it â€” you want to move all API-related logic (Supabase calls + login processing) out of your <Login /> component and into a separate clean service file, while keeping your UI clean.
Below is the perfect clean architecture for your use case.

âœ… Final Folder Structure (Recommended)
src/
 â”œâ”€â”€ api/
 â”‚    â”œâ”€â”€ supabase.ts
 â”‚    â””â”€â”€ authService.ts   <-- create this (all API calls here)
 â”œâ”€â”€ pages/
 â”‚    â””â”€â”€ auth/
 â”‚         â””â”€â”€ Login.tsx   <-- UI only


âœ… Create authService.ts (all API calls here)
ðŸ“Œ This file contains:


email/password login


Google OAuth login


user table fetch/insert/update


processUserLogin logic


auth state listener


ðŸ‘‰ Just import and call these functions from your component.

src/api/authService.ts
import { supabase } from "./supabase";

/* ------------------ EMAIL + PASSWORD LOGIN ------------------ */
export const loginWithEmail = async (email: string, password: string) => {
  return await supabase.auth.signInWithPassword({ email, password });
};

/* ------------------ GOOGLE LOGIN ------------------ */
export const loginWithGoogle = async () => {
  return await supabase.auth.signInWithOAuth({
    provider: "google",
    options: {
      redirectTo: `${window.location.origin}/login`,
      queryParams: { access_type: "offline", prompt: "consent" },
    },
  });
};

/* ------------------ GET SESSION ------------------ */
export const getCurrentSession = async () => {
  return await supabase.auth.getSession();
};

/* ------------------ LISTEN AUTH CHANGES ------------------ */
export const handleAuthListener = (callback: Function) => {
  const { data: { subscription } } = supabase.auth.onAuthStateChange(
    async (event, session) => {
      callback(event, session);
    }
  );

  return () => subscription.unsubscribe();
};

/* ------------------ FETCH USER FROM TABLE ------------------ */
export const getUserFromDB = async (userId: string) => {
  return await supabase
    .from("usersTable")
    .select("id, email, language_preference, theme_preference, profile_picture, full_name , capital_view")
    .eq("id", userId)
    .single();
};

/* ------------------ INSERT NEW USER ------------------ */
export const insertUserIntoDB = async (payload: any) => {
  return await supabase.from("usersTable").insert(payload).select().single();
};

/* ------------------ UPDATE USER ------------------ */
export const updateUserInDB = async (userId: string, updateData: any) => {
  return await supabase
    .from("usersTable")
    .update(updateData)
    .eq("id", userId);
};


âœ… Move processUserLogin into the service
Add this inside authService.ts:

processUserLogin (clean & reusable)
import { getUserFromDB, insertUserIntoDB, updateUserInDB } from "./authService";

export const processUserLoginService = async (session: any) => {
  const userId = session?.user?.id;
  if (!userId) return { error: "User ID missing" };

  // Extract metadata
  const userMetadata = session.user.user_metadata;
  const profilePicture = userMetadata?.avatar_url || userMetadata?.picture || "";
  const fullName = userMetadata?.full_name || userMetadata?.name || "";

  // Check if user exists
  const { data: userDetails, error: userTableError } = await getUserFromDB(userId);

  // User does NOT exist â†’ create new one
  if (userTableError || !userDetails) {
    const payload = {
      id: userId,
      email: session.user.email,
      full_name: fullName,
      profile_picture: profilePicture,
      language_preference: "en",
      theme_preference: "light",
      created_at: new Date(),
      is_Verified: true,
      capital_view: "graph",
    };

    const { data: newUser, error: insertError } = await insertUserIntoDB(payload);

    if (insertError) return { error: insertError.message };

    return { user: newUser };
  }

  // User exists â†’ update basic info if needed
  const updatedData: any = {};
  if (profilePicture && profilePicture !== userDetails.profile_picture)
    updatedData.profile_picture = profilePicture;
  if (fullName && fullName !== userDetails.full_name)
    updatedData.full_name = fullName;

  if (Object.keys(updatedData).length > 0)
    await updateUserInDB(userId, updatedData);

  return { user: { ...userDetails, ...updatedData } };
};


âœ… Now your <Login /> component becomes super clean
All API calls go through your new authService.

Login.tsx (clean UI + service usage)
import {
  loginWithEmail,
  loginWithGoogle,
  getCurrentSession,
  handleAuthListener,
  processUserLoginService,
} from "../../api/authService";

Then update the functions:

Handle Email Login (clean)
const handleLogin = async (data: LoginFormValues) => {
  setIsLoading(true);

  const { data: loginData, error } = await loginWithEmail(data.email, data.password);

  if (error) {
    enqueueSnackbar(error.message, { variant: "error" });
    dispatch(setError());
    setIsLoading(false);
    return;
  }

  const result = await processUserLoginService(loginData.session);

  if (result.error) {
    enqueueSnackbar(result.error, { variant: "error" });
    setIsLoading(false);
    return;
  }

  dispatch(loginSuccess({
    user: result.user,
    accessToken: loginData.session.access_token,
    refreshToken: loginData.session.refresh_token
  }));

  enqueueSnackbar("Login successful!", { variant: "success" });
  navigate("/", { replace: true });
  setIsLoading(false);
};


Handle Google Login
const handleGoogleLogin = async () => {
  setIsLoading(true);
  const { error } = await loginWithGoogle();

  if (error) {
    enqueueSnackbar(error.message, { variant: "error" });
    dispatch(setError());
  }

  setIsLoading(false);
};


OAuth Listener + Session Handling
useEffect(() => {
  const checkSession = async () => {
    const { data: { session } } = await getCurrentSession();

    if (session) {
      const result = await processUserLoginService(session);

      if (!result.error) {
        dispatch(loginSuccess({
          user: result.user,
          accessToken: session.access_token,
          refreshToken: session.refresh_token
        }));
        navigate("/", { replace: true });
      }
    }
  };

  checkSession();
  const unsub = handleAuthListener(async (event: string, session: any) => {
    if (event === "SIGNED_IN" && session) {
      const result = await processUserLoginService(session);

      if (!result.error) {
        dispatch(loginSuccess({
          user: result.user,
          accessToken: session.access_token,
          refreshToken: session.refresh_token
        }));
        navigate("/", { replace: true });
      }
    }
  });

  return () => unsub();
}, []);


ðŸŽ‰ Output:
Your Login component now contains ONLY UI + simple service calls.
All Supabase logic is extracted into authService.ts.
Clean, scalable, easy to maintain.

If you want, I can also:
âœ… Move API calls to Redux Thunks
âœ… Set up RTK Query for authentication
âœ… Create a clean architecture folder structure (services â†’ usecases â†’ controllers â†’ UI)
Just tell me!
































// src/api/authApi.ts
import { supabase } from "./supabase";

export const signUpRequest = async (email: string, password: string) => {
  const { data, error } = await supabase.auth.signUp({
    email,
    password,
  });
  return { data, error };
};

export const loginRequest = async (email: string, password: string) => {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });
  return { data, error };
};

export const googleLoginRequest = async () => {
  return await supabase.auth.signInWithOAuth({
    provider: "google",
    options: {
      redirectTo: `${window.location.origin}/login`,
      queryParams: { access_type: "offline", prompt: "consent" },
    },
  });
};

// =========================
// USER TABLE OPERATIONS
// =========================

// Get or create user in usersTable
export const getUserFromTable = async (userId: string) => {
  return await supabase
    .from("usersTable")
    .select(
      "id, email, language_preference, theme_preference, profile_picture, full_name, capital_view"
    )
    .eq("id", userId)
    .single();
};

export const insertUserToTable = async (user: any) => {
  return await supabase
    .from("usersTable")
    .insert(user)
    .select()
    .single();
};

export const updateUserProfileInTable = async (userId: string, updateData: any) => {
  return await supabase
    .from("usersTable")
    .update(updateData)
    .eq("id", userId);
};

// Get active session (OAuth callback)
export const getCurrentSession = async () => {
  return await supabase.auth.getSession();
};

// Listen to auth state change
export const authStateListener = (callback: any) => {
  return supabase.auth.onAuthStateChange(callback);
};

































import { useState, useEffect } from "react";
import { useDispatch } from "react-redux";
import { loginSuccess, setError } from "../../redux/slices/authSlice";
import { useSnackbar } from "notistack";
import { useNavigate } from "react-router-dom";
import { useForm } from "react-hook-form";

import {
  loginRequest,
  googleLoginRequest,
  getSessionRequest,
  fetchUserFromDB,
  createUserInDB,
  updateUserInDB,
} from "../../api/authApi";

interface LoginFormValues {
  email: string;
  password: string;
}

const EyeIcon = () => <img src="./logos/eye-on.svg" className="h-4 w-4" />;
const EyeOffIcon = () => <img src="./logos/eye-off.svg" className="h-4 w-4" />;

export default function Login() {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const { enqueueSnackbar } = useSnackbar();

  const [showPassword, setShowPassword] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const {
    register,
    handleSubmit,
    watch,
    formState: { errors },
  } = useForm<LoginFormValues>();

  const password = watch("password");

  // =============================
  // OAuth Callback Listener
  // =============================
  useEffect(() => {
    const handleOAuthCallback = async () => {
      try {
        const { session, error } = await getSessionRequest();

        if (error) return;

        if (session?.user) await processUserLogin(session);
      } catch (err) {
        console.error("OAuth callback error:", err);
      }
    };

    handleOAuthCallback();
  }, []);

  // =============================
  // @Process Login (Common)
  // =============================
  const processUserLogin = async (session: any, redirectToDashboard = true) => {
    try {
      setIsLoading(true);

      const userId = session?.user?.id;
      if (!userId) {
        enqueueSnackbar("Login failed: User ID not found.", { variant: "error" });
        dispatch(setError());
        return;
      }

      const metadata = session.user.user_metadata;
      const profilePicture =
        metadata?.avatar_url || metadata?.picture || "";
      const fullName = metadata?.full_name || metadata?.name || "";

      // Check user in DB
      const { userDetails, error: userError } = await fetchUserFromDB(userId);

      if (userError || !userDetails) {
        // Create new user
        const { newUser, error: createErr } = await createUserInDB({
          id: userId,
          email: session.user.email,
          full_name: fullName,
          profile_picture: profilePicture,
        });

        if (createErr) {
          dispatch(setError());
          return;
        }

        dispatch(
          loginSuccess({
            user: newUser,
            accessToken: session?.access_token,
            refreshToken: session?.refresh_token,
          })
        );

        enqueueSnackbar("Login successful!", { variant: "success" });
        if (redirectToDashboard) navigate("/", { replace: true });

        return;
      }

      // Update user profile if changed
      const updatePayload: any = {};
      if (profilePicture && profilePicture !== userDetails.profile_picture)
        updatePayload.profile_picture = profilePicture;

      if (fullName && fullName !== userDetails.full_name)
        updatePayload.full_name = fullName;

      if (Object.keys(updatePayload).length > 0) {
        await updateUserInDB(userId, updatePayload);
      }

      dispatch(
        loginSuccess({
          user: { ...userDetails, ...updatePayload },
          accessToken: session?.access_token,
          refreshToken: session?.refresh_token,
        })
      );

      enqueueSnackbar("Login successful!", { variant: "success" });
      if (redirectToDashboard) navigate("/", { replace: true });

    } catch (error) {
      console.error("Process login error:", error);
      enqueueSnackbar("Failed to process login!", { variant: "error" });
      dispatch(setError());
    } finally {
      setIsLoading(false);
    }
  };

  // =============================
  // Email/Password Login Handler
  // =============================
  const handleLogin = async (data: LoginFormValues) => {
    try {
      setIsLoading(true);

      const { loginData, error } = await loginRequest(data.email, data.password);

      if (error) {
        enqueueSnackbar(error.message, { variant: "error" });
        dispatch(setError());
        return;
      }

      await processUserLogin(loginData.session);
    } catch (error) {
      console.error(error);
      enqueueSnackbar("Something went wrong", { variant: "error" });
      dispatch(setError());
    } finally {
      setIsLoading(false);
    }
  };

  // =============================
  // Google Login Handler
  // =============================
  const handleGoogleLogin = async () => {
    try {
      setIsLoading(true);

      const { error } = await googleLoginRequest();

      if (error) {
        enqueueSnackbar(error.message, { variant: "error" });
        dispatch(setError());
      }
    } catch (error) {
      console.error("Google login error:", error);
      enqueueSnackbar("Google login failed!", { variant: "error" });
      dispatch(setError());
    } finally {
      setIsLoading(false);
    }
  };

  // =============================
  // Render UI
  // =============================
  return (
    <div className="min-h-screen flex justify-center items-center bg-gray-100">
      <form
        onSubmit={handleSubmit(handleLogin)}
        className="bg-white p-6 rounded-md shadow-md w-96 space-y-4"
      >
        <h2 className="text-xl font-semibold">Login</h2>

        <div>
          <label>Email</label>
          <input
            {...register("email", { required: "Email is required" })}
            className="w-full p-2 border rounded"
          />
          {errors.email && (
            <p className="text-red-600 text-sm">{errors.email.message}</p>
          )}
        </div>

        <div>
          <label>Password</label>
          <div className="relative">
            <input
              {...register("password", { required: "Password is required" })}
              type={showPassword ? "text" : "password"}
              className="w-full p-2 border rounded"
            />

            <span
              className="absolute right-3 top-3 cursor-pointer"
              onClick={() => setShowPassword(!showPassword)}
            >
              {showPassword ? <EyeOffIcon /> : <EyeIcon />}
            </span>
          </div>
        </div>

        <button
          disabled={isLoading}
          className="w-full bg-blue-600 text-white p-2 rounded-md"
        >
          {isLoading ? "Loading..." : "Login"}
        </button>

        <button
          type="button"
          onClick={handleGoogleLogin}
          className="w-full flex justify-center items-center gap-2 p-2 border rounded-md"
        >
          <img src="./logos/google.png" className="h-4" />
          <span>Continue with Google</span>
        </button>
      </form>
    </div>
  );
}
